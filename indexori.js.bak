require('./settings');
const { default: makeWASocket, makeCacheableSignalKeyStore, useMultiFileAuthState, fetchLatestBaileysVersion, makeInMemoryStore, downloadContentFromMessage, jidDecode } = require('@whiskeysockets/baileys');
const { Boom } = require('@hapi/boom');
const pino = require('pino');
const readline = require('readline');
const chalk = require('chalk');
const fs = require('fs');
const path = require('path');
const NodeCache = require('node-cache');
const FileType = require('file-type');
const PhoneNumber = require('awesome-phonenumber');
const axios = require('axios');
const lolcatjs = require('lolcatjs');
const { formatSize, runtime, sleep, serialize, smsg, color, getBuffer } = require("./App/function/myfunc")
const { imageToWebp, videoToWebp, writeExifImg, writeExifVid } = require('./App/function/exif')
const { toAudio, toPTT, toVideo } = require('./App/function/converter')

const low = require('./App/lowdb');
const store = makeInMemoryStore({ 
    logger: pino().child({ 
        level: "silent", 
        stream: "store" 
    }) 
});

const msgRetryCounterCache = new NodeCache();
const processedMessages = new Set();

const usePairingCode = true;

async function nvdiaStarted() {
    const { version, isLatest } = await fetchLatestBaileysVersion();
    const { state, saveCreds } = await useMultiFileAuthState("./storage/session");
    
	const nvdia = makeWASocket({
		printQRInTerminal: !usePairingCode,
		syncFullHistory: true,
		markOnlineOnConnect: true,
		connectTimeoutMs: 60000, 
		defaultQueryTimeoutMs: 0,
		keepAliveIntervalMs: 10000,
		generateHighQualityLinkPreview: true, 
		patchMessageBeforeSending: (message) => {
			const requiresPatch = !!(
				message.buttonsMessage 
				|| message.templateMessage
				|| message.listMessage
			);
			if (requiresPatch) {
				message = {
					viewOnceMessage: {
						message: {
							messageContextInfo: {
								deviceListMetadataVersion: 2,
								deviceListMetadata: {},
							},
							...message,
						},
					},
				};
			}

			return message;
		},
		version: (await (await fetch('https://raw.githubusercontent.com/WhiskeySockets/Baileys/master/src/Defaults/baileys-version.json')).json()).version,
		browser: ["Ubuntu", "Chrome", "20.0.04"],
		logger: pino({ level: 'fatal' }),
		auth: { 
			creds: state.creds, 
			keys: makeCacheableSignalKeyStore(state.keys, pino().child({ 
				level: 'silent', 
				stream: 'store' 
			})), 
		}
	});

    // Pairing Code Logic
    if (usePairingCode && !nvdia.authState.creds.registered) {
        lolcatjs.fromString(`⣿⣿⣷⡁⢆⠈⠕⢕⢂⢕⢂⢕⢂⢔⢂⢕⢄⠂⣂⠂⠆⢂⢕⢂⢕⢂⢕⢂⢕⢂
⣿⣿⣿⡷⠊⡢⡹⣦⡑⢂⢕⢂⢕⢂⢕⢂⠕⠔⠌⠝⠛⠶⠶⢶⣦⣄⢂⢕⢂⢕
⣿⣿⠏⣠⣾⣦⡐⢌⢿⣷⣦⣅⡑⠕⠡⠐⢿⠿⣛⠟⠛⠛⠛⠛⠡⢷⡈⢂⢕⢂
⠟⣡⣾⣿⣿⣿⣿⣦⣑⠝⢿⣿⣿⣿⣿⣿⡵⢁⣤⣶⣶⣿⢿⢿⢿⡟⢻⣤⢑⢂
⣾⣿⣿⡿⢟⣛⣻⣿⣿⣿⣦⣬⣙⣻⣿⣿⣷⣿⣿⢟⢝⢕⢕⢕⢕⢽⣿⣿⣷⣔
⣿⣿⠵⠚⠉⢀⣀⣀⣈⣿⣿⣿⣿⣿⣿⣿⣿⣿⣗⢕⢕⢕⢕⢕⢕⣽⣿⣿⣿⣿
⢷⣂⣠⣴⣾⡿⡿⡻⡻⣿⣿⣴⣿⣿⣿⣿⣿⣿⣷⣵⣵⣵⣷⣿⣿⣿⣿⣿⣿⡿
⢌⠻⣿⡿⡫⡪⡪⡪⡪⣺⣿⣿⣿⣿⣿⠿⠿⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠃
⠣⡁⠹⡪⡪⡪⡪⣪⣾⣿⣿⣿⣿⠋⠐⢉⢍⢄⢌⠻⣿⣿⣿⣿⣿⣿⣿⣿⠏⠈
⡣⡘⢄⠙⣾⣾⣾⣿⣿⣿⣿⣿⣿⡀⢐⢕⢕⢕⢕⢕⡘⣿⣿⣿⣿⣿⣿⠏⠠⠈
⠌⢊⢂⢣⠹⣿⣿⣿⣿⣿⣿⣿⣿⣧⢐⢕⢕⢕⢕⢕⢅⣿⣿⣿⣿⡿⢋⢜⠠⠈
⠄⠁⠕⢝⡢⠈⠻⣿⣿⣿⣿⣿⣿⣿⣷⣕⣑⣑⣑⣵⣿⣿⣿⡿⢋⢔⢕⣿⠠⠈
⠨⡂⡀⢑⢕⡅⠂⠄⠉⠛⠻⠿⢿⣿⣿⣿⣿⣿⣿⣿⣿⡿⢋⢔⢕⢕⣿⣿⠠⠈
⠄⠪⣂⠁⢕⠆⠄⠂⠄⠁⡀⠂⡀⠄⢈⠉⢍⢛⢛⢛⢋⢔⢕⢕⢕⣽⣿⣿⠠⠈`);
        console.log(`Is connecting Number ${global.pairing}\n`);
        
        try {
            await new Promise(resolve => setTimeout(resolve, 4000));
            const code = await nvdia.requestPairingCode(global.pairing);
            console.log('Process...');
            console.log(`Your Pairing Code: ${chalk.yellow.bold(code)}`);
        } catch (err) {
            console.error(chalk.red("Gagal membuat pairing code:"), err.message);
            process.exit(1);
        }
    }

    store.bind(nvdia.ev);

    // Messages Handler
    nvdia.ev.on('messages.upsert', async msgUpdate => {
        try {
            const messages = msgUpdate.messages;
            const msg = messages[0];
            if (!msg.message) return;
            msg.message = (Object.keys(msg.message)[0] === 'ephemeralMessage') 
                ? msg.message.ephemeralMessage.message 
                : msg.message;
            
            if (msg.key && msg.key.remoteJid === 'status@broadcast') return;
            if (msg.key.id.startsWith('BAE5') && msg.key.id.length === 16) return;
            
            const messageId = msg.key.id;
            if (processedMessages.has(messageId)) return;
            processedMessages.add(messageId);
            const m = smsg(nvdia, msg, store);
            // Replace with your message handling logic
            require('./case.js').handleIncomingMessage(nvdia, m,  msg);
        } catch (err) {
            console.log(err);
        }
    });

    // Connection Update Event
    nvdia.ev.on("connection.update", async (s) => {
        const { connection, lastDisconnect } = s;
        if (connection == "open") {
            console.log(chalk.green.bold(`Bot Connected: ${nvdia.user.id.split(':')[0]}`));
        }
        
        if (connection === "close" && 
            lastDisconnect && 
            lastDisconnect.error && 
            lastDisconnect.error.output.statusCode != 401) {
            nvdiaStarted();
        }
    });

    // Credentials Update Event
    nvdia.ev.on("creds.update", saveCreds);

    // Utility Methods
    nvdia.decodeJid = (jid) => {
        if (!jid) return jid;
        if (/:\d+@/gi.test(jid)) {
            let decode = jidDecode(jid) || {};
            return (decode.user && decode.server && decode.user + "@" + decode.server) || jid;
        } else {
            return jid;
        }
    };

    nvdia.getName = async (jid, withoutContact = false) => {
        id = nvdia.decodeJid(jid);
        withoutContact = nvdia.withoutContact || withoutContact;
        let v;

        if (id.endsWith("@g.us")) {
            return new Promise(async (resolve) => {
                v = store.contacts[id] || {};
                if (!(v.name || v.subject)) v = await nvdia.groupMetadata(id) || {};
                resolve(v.name || v.subject || PhoneNumber("+" + id.replace("@s.whatsapp.net", "")).getNumber("international"));
            });
        } else {
            v = id === "0@s.whatsapp.net"
                ? { id, name: "WhatsApp" }
                : id === nvdia.decodeJid(nvdia.user.id)
                    ? nvdia.user
                    : store.contacts[id] || {};
        }

        return (withoutContact ? "" : v.name) || v.subject || v.verifiedName || PhoneNumber("+" + jid.replace("@s.whatsapp.net", "")).getNumber("international");
    };

    // Additional Methods (getFile, downloadMediaMessage, etc.)
    nvdia.getFile = async (PATH, returnAsFilename) => {
        let res, filename;
        const data = Buffer.isBuffer(PATH) 
            ? PATH 
            : /^data:.*?\/.*?;base64,/i.test(PATH) 
                ? Buffer.from(PATH.split`,` [1], 'base64') 
                : /^https?:\/\//.test(PATH) 
                    ? await (res = await fetch(PATH)).buffer() 
                    : fs.existsSync(PATH) 
                        ? (filename = PATH, fs.readFileSync(PATH)) 
                        : typeof PATH === 'string' 
                            ? PATH 
                            : Buffer.alloc(0);

        if (!Buffer.isBuffer(data)) throw new TypeError('Result is not a buffer');

        const type = await FileType.fromBuffer(data) || {
            mime: 'application/octet-stream',
            ext: '.bin'
        };

        if (data && returnAsFilename && !filename) {
            filename = path.join(__dirname, './tmp/' + new Date * 1 + '.' + type.ext);
            await fs.promises.writeFile(filename, data);
        }

        return {
            res,
            filename,
            ...type,
            data,
            deleteFile() {
                return filename && fs.promises.unlink(filename);
            }
        };
    };

    nvdia.downloadMediaMessage = async (message) => {
        let mime = (message.msg || message).mimetype || '';
        let messageType = message.mtype ? message.mtype.replace(/Message/gi, '') : mime.split('/')[0];
        const stream = await downloadContentFromMessage(message, messageType);
        let buffer = Buffer.from([]);

        for await (const chunk of stream) {
            buffer = Buffer.concat([buffer, chunk]);
        }
        return buffer;
    };

    nvdia.sendFile = async (jid, path, filename = '', caption = '', quoted, ptt = false, options = {}) => {
        let type = await nvdia.getFile(path, true);
        let { res, data: file, filename: pathFile } = type;

        if (res && res.status !== 200 || file.length <= 65536) {
            try {
                throw { json: JSON.parse(file.toString()) };
            } catch (e) {
                if (e.json) throw e.json;
            }
        }

        let opt = { filename };
        if (quoted) opt.quoted = quoted;
        if (!type) options.asDocument = true;

        let mtype = '', mimetype = type.mime, convert;

        if (/webp/.test(type.mime) || (/image/.test(type.mime) && options.asSticker)) {
            mtype = 'sticker';
        } else if (/image/.test(type.mime) || (/webp/.test(type.mime) && options.asImage)) {
            mtype = 'image';
        } else if (/video/.test(type.mime)) {
            mtype = 'video';
        } else if (/audio/.test(type.mime)) {
            convert = await (ptt ? toPTT : toAudio)(file, type.ext);
            file = convert.data;
            pathFile = convert.filename;
            mtype = 'audio';
            mimetype = 'audio/ogg; codecs=opus';
        } else {
            mtype = 'document';
        }

        if (options.asDocument) mtype = 'document';

        let message = {
            ...options,
            caption,
            ptt,
            [mtype]: { url: pathFile },
            mimetype
        };

        let m;
        try {
            m = await nvdia.sendMessage(jid, message, { ...opt, ...options });
        } catch (e) {
            console.error(e);
            m = null;
        } finally {
            if (!m) m = await nvdia.sendMessage(jid, { ...message, [mtype]: file }, { ...opt, ...options });
            return m;
        }
    };

    nvdia.sendTextWithMentions = async (jid, text, quoted, options = {}) => {
        return nvdia.sendMessage(jid, {
            text: text,
            contextInfo: {
                mentionedJid: [...text.matchAll(/@(\d{0,16})/g)].map(v => v[1] + '@s.whatsapp.net')
            },
            ...options
        }, { quoted });
    };

    nvdia.sendVideoAsSticker = async (jid, path, quoted, options = {}) => {
        let buff = Buffer.isBuffer(path) 
            ? path 
            : /^data:.*?\/.*?;base64,/i.test(path) 
                ? Buffer.from(path.split`,`[1], 'base64') 
                : /^https?:\/\//.test(path) 
                    ? await (await getBuffer(path)) 
                    : fs.existsSync(path) 
                        ? fs.readFileSync(path) 
                        : Buffer.alloc(0);

        let buffer;
        if (options && (options.packname || options.author)) {
            buffer = await writeExifVid(buff, options);
        } else {
            buffer = await videoToWebp(buff);
        }

        await nvdia.sendMessage(jid, { sticker: { url: buffer }, ...options }, { quoted });
        return buffer;
    };

    nvdia.downloadAndSaveMediaMessage = async (message, filename, attachExtension = true) => {
        let quoted = message.msg ? message.msg : message;
        let mime = (message.msg || message).mimetype || '';
        let messageType = message.mtype ? message.mtype.replace(/Message/gi, '') : mime.split('/')[0];
        const stream = await downloadContentFromMessage(quoted, messageType);
        let buffer = Buffer.from([]);
        
        for await (const chunk of stream) {
            buffer = Buffer.concat([buffer, chunk]);
        }
        
        let type = await FileType.fromBuffer(buffer);
        let trueFileName = attachExtension ? (filename + '.' + type.ext) : filename;
        let savePath = path.join(__dirname, 'tmp', trueFileName);
        await fs.writeFileSync(savePath, buffer);
        
        return savePath;
    };

    nvdia.sendImageAsSticker = async (jid, path, quoted, options = {}) => {
        let buff = Buffer.isBuffer(path) ? path : 
            /^data:.*?\/.*?;base64,/i.test(path) ? Buffer.from(path.split`,`[1], 'base64') : 
            /^https?:\/\//.test(path) ? await (await getBuffer(path)) : 
            fs.existsSync(path) ? fs.readFileSync(path) : Buffer.alloc(0);
        
        let buffer;
        if (options && (options.packname || options.author)) {
            buffer = await writeExifImg(buff, options);
        } else {
            buffer = await imageToWebp(buff);
        }
        
        await nvdia.sendMessage(jid, { sticker: { url: buffer }, ...options }, { quoted });
        return buffer;
    };

    nvdia.sendImage = async (jid, path, caption = "", quoted = "", options = {}) => {
        let buffer = Buffer.isBuffer(path) ? path : 
            /^data:.*?\/.*?;base64,/i.test(path) ? Buffer.from(path.split`,`[1], "base64") : 
            /^https?:\/\//.test(path) ? await (await getBuffer(path)) : 
            fs.existsSync(path) ? fs.readFileSync(path) : Buffer.alloc(0);
        
        return await nvdia.sendMessage(
            jid,
            { image: buffer, caption: caption, ...options },
            { quoted: quoted }
        );
    };

    nvdia.sendText = (jid, text, quoted = '', options) => nvdia.sendMessage(jid, { text: text, ...options }, { quoted });

    nvdia.public = true;

    return nvdia;
}

// Start the bot
nvdiaStarted();

// File watcher for auto-reload
let file = require.resolve(__filename);
fs.watchFile(file, () => {
    fs.unwatchFile(file);
    console.log(chalk.blue(`Update ${__filename}`));
    delete require.cache[file];
    require(file);
});
